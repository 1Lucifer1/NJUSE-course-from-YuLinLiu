# 团队工程开发

## 需求

### 需求开发

+ 需求是一切工程活动的基础。
+ 需求类别
  + 客户需求
  + 产品需求
  + 产品组件需求

### 需求获取

+ 客户所受到的限制也应当作为需求开发过程中需要重点关注的内容。

+ 通常采取所谓的需求“诱导”方式进行。

+ “诱导”一词的含义不仅仅是普通的需求采集，它隐含了应更加积极地、前瞻性地识别那些客户没有明确提供的额外需求。
+ 需求获取就是要尽可能识别客户的期望与所受的限制。
+ 客户在描述其期望时一般不会显式提出这些额外的需求，然而这些需求却会对整个开发周期以及最终产品都会产生影响。

### 需求汇总

+ 整理各种来源的信息，识别缺失的信息

+ 解决冲突的需求
+ 需求的整理和转化
+ 推导未显式描述的需求内容

### 需求验证

+ 对需求进行分析和确认，以确保符合使用者预期

+ 典型活动包括
  + 建立和维护操作概念和相关的场景
  + 分析需求，以确保其必要性、充分性和平衡性。
  + 确认需求，以确保将要产生的产品能在预期的用户环境中运行并且工作正常。
+ 设计解决方案 -> 场景 -> 确认需求

### 需求文档制作

+ 需求开发工作完成的一个基本标志是形成了一份完整的、规范的、经过评审的需求规格说明书。

+ 需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。
+ 需求文档是必须的

### 需求文档特征

+ 内聚特征：需求规格描述应当尽可能内聚，即仅仅用以说明一件事情。
+ 完整特征：需求规格描述应当完整，不能遗漏信息。
+ 一致特征：需求规格描述的各个条目和章节不能互相矛盾，需求规格描述与所有外部的参考资料之间也应当消除矛盾之处。
+ 原子特征：需求规格描述的过程中，应当尽可能避免连接词的使用。如果需要描述多项内容，可以分别用简单语句加以描述。
+ 可跟踪特征：客户需求、产品需求以及产品组件需求必须可以双向跟踪，即客户需求的任何内容，都应当在产品需求和产品组件需求中得到体现。反之，产品组件需求的每一项描述也要可以跟踪到客户需求中的内容。
+ 非过期特征：需求描述的内容必须体现相关干系人对于项目的最新认识。即不能包含已经废弃的需求定义。
+ 可行性特征：需求规格描述的各项内容应该在项目所拥有的资源范围内可以实现。
+ 非二义性特征：需求规格描述应当尽可能清晰、客观。不能有含糊不清或者可以有多种理解的情形。
+ 强制特征：需求规格描述的内容应当体现强制性，即需求规格描述的内容的任何一项缺失，都会导致最终产品不能满足客户期望。因此，可选的需求内容要么不要出现，要么以明确的方式标注。
+ 可验证特征：需求规格描述应当便于在后期开发过程中进行验证。即实现该需求与否，应该有明确的判断标准。

## 团队

### 团队设计

+ 设计过程与PSP基本一致
+ 团队设计面向整体开发，因此需要额外考虑如下内容：
  + 团队智慧的使用
  + 设计标准
  + 设计复用
  + 设计的可测试性支持
  + 设计的可用性支持等要求

### 团队智慧

+ 发挥团队智慧两大挑战：
  + 确定整体架构之前很难进行分工
  + 鼓励团队成员在讨论和评审会议中的参与程度

### 设计标准

团队设计当中非常重要的一点就是定义合适的团队设计标准。设计标准有很多类型，典型标准包括命名规范、接口标准、系统出错信息和设计表示标准等。简要介绍如下：

+ 命名规范

项目小组应当设计一个统一的命名规范来命名各个模块并建立系统词典，用以描述各个模块。系统词典在整个系统的设计、实现以及支持文档的开发过程中要时刻保持可用状态。此外，还需要通过命名规范来约定系统的架构类型和名称，典型的包括系统、子系统、组件、模块、程序等。在编码过程中程序的命名、文件的命名、变量的命名以及参数的命名等都需要通过命名规范加以定义。

+ 接口标准

组件之间的接口标准和格式也需要作为设计标准的内容之一加以定义。事实上，软件工程的一些设计原则，如高内聚、低耦合等也应当作为接口标准定义的内容，从而约束了模块之间信息交互的方式。

+ 系统出错信息

系统异常信息和出错信息往往也需要通过一个规范加以标准化。从而使得出错信息有个一致的、便于理解的描述。此外，也便于在设计和开发中的复用。

+ 设计表示标准

设计表示标准定义了设计工作的产物应当满足的标准。这有可能是所有设计标准中最为重要的一项内容。在设计表示标准的定义中，必须明确给出完整而准确地表示设计结果的标准。从而帮助项目团队用一致的方式来表现其设计结果。在本书4.3节中介绍的PSP设计模板可以作为设计表示标准的基础，项目小组可以基于4个设计模板，再参考设计的层次，合理定义团队设计表示的标准。

### 复用性支持

自底向上实现

复用可以显著提升团队生产效率和质量水平，然而，问题是复用的机会并不是偶然发生的，需要设计人员在项目尽可能的早期加以考虑。“Design For Reuse”被很多软件工程方法识别为最佳实践。这句话就深刻体现了在设计的时候，需要为了创造复用机会而又一些特别的考虑。

+ 复用接口标准

在识别可复用组件的时候，需要以高内聚、低耦合的的设计思想来设计可复用组件。另外，为了便于使用，还得定义复用组件的接口标准，比如参数、变量、返回值以及异常消息的格式与命名等。

+ 复用文档标准

通常软件工程师在识别复用组件时，往往直接研究代码，这相当耗时。因此，大部分软件工程师倾向于使用自己开发的复用组件。在团队开发中，为了尽可能提升复用机会，对于可复用组件必须提供详细支持文档，便于团队其他人使用。在文档中需明确组件功能、调用方式、返回值类型以及可能的异常信息。此外，项目团队应当为复用文档定义一个统一的模板和标准。

+ 复用质量保证

复用组件由于有可能在整个系统的多处被使用，因此，复用组件的质量有尤其重要。否则，复用组件中的一个错误会被传播到软件系统各处。为了获得较高的组件质量，建议采用高质量过程来开发，如PSP2.1过程。另外，还得对待复用组件进行充分的测试。根据过程数据来判断复用组件的质量。

### 可测试性考虑

+ 设计可测试性考虑主要体现在两方面：一是要尽可能减少测试代码的数量；二是要制作合理的测试计划。
+ 减少测试代码的数量主要通过合理的架构设计来体现。而合理的测试计划对于可测试性的帮助往往被忽视。事实上，充分开展测试计划的开发工作，往往可以在计划阶段就可以发向相当多的缺陷，甚至比真正的测试工作发现的缺陷还要多。完整的设计工作和操作场景定义，有助于更好的开展测试计划工作。

### 可用性考虑

+ 可用性的问题应当在设计阶段就开始考虑，而不能推延到实现阶段。
+ 针对每一个关键功能都定义操作概念和操作场景。
+ 分析操作场景以确保软件系统开发完成之后，系统使用者会满意。
+ 必要时，可以邀请最终用户参与场景的评审，使用模拟、原型等技术，更好的把握用户真实意图。

### 实现策略

+ 评审的考虑

在设计的过程当中，采取的基本策略是自顶向下，逐层精化的策略。这有利于建立系统的整体观。然而，在实现过程当中，应当更多的考虑到是否便于对实现结果的评审。因此，建议采取的策略是自底向上进行实现。按照这种策略，在实现的过程中优先实现底层的内容，然后这些底层的模块进行评审，以确保其质量。然后基于有着坚实质量基础的模块，再进行高层实现。

此外，这种策略还有利于复用策略的应用。已经实现了的底层模块有着更多被复用的机会。

+ 复用策略

除了上述的自底向上实现策略来支持复用之外，为了更加有效支持复用，还需要其他的一些实践。例如，编码注释的应用和每天站立式会议的应用。编码注释应当使用统一的格式，在每个源码文件的开头明确提供有利于复用的重要信息，如功能、调用方式、异常信息等。必要时，可以结合一些自动化工具来自动收集这些信息，便于查询。

每天进行站立式会议是有效提升复用机会的手段。在会上，团队成员可以讨论实现计划，识别可复用组件，了解现有的复用组件库中的内容。从而在设计和实现当中抓住复用机会。

+ 可测试性考虑

实现阶段对于可测试性的考虑主要体现在实现的计划必须与测试计划一致，从而避免进行集成测试的时候，部分模块没有实现所带来的不便。

### 集成策略选择

+ 大爆炸集成策略

该策略将所有已经完成的组件放在一起，进行一次集成。这是一种看起来非常具有吸引力策略。因为这有可能是需要测试用例最少的一种方式。然而，这需要所有待集成的产品组件都具有较高的质量水平，否则，难以定位缺陷位置的缺点会使得该策略消耗很多测试时间。而且，系统越复杂、规模越大，问题越突出。

+ 逐一添加集成策略

该策略与上述的大爆炸集成策略完全相反，采取一次添加一个组件的方式进行集成。因此其优点就在于很容易定位缺陷的位置，特别在产品组件质量不高的情况下，每次集成之前都有着坚实的质量基础。但是，该方法的缺点也很突出。这可能是需要测试用例最多的一种策略，而且，大量的回归测试也会消耗很多时间。

+ 集簇集成策略

集簇集成策略是对逐一添加集成策略的改进。简单的随机选择产品组件进行集成并不合理。为了提升测试效率，往往会把有相似功能或者有关联的模块优先进行集成，形成可以工作的组件。然后以组件为单位继续较高层次的集成。此外，这种策略还有一个好处就是，可以尽早获得一些可以工作的组件，有利于其他组件测试工作的开展。但是，这种策略的缺点是过于关注个别组件，而缺乏系统的整体观，不能尽早发现系统层面的缺陷。

+ 扁平化集成策略

该策略要求尽快构建一个可以工作的扁平化系统。也就是说，优先集成高层的部件，然后逐步将各个组件、模块的真正实现加入系统。这种方式可以尽早发现系统层面的缺陷。然而，该策略的缺陷是为了确保完成的系统，需要大量的打“桩”（stub），即提供一些直接提供返回值的伪实现。这种方式往往不能覆盖整个系统应该处理的多种状态。

## 验证与确认

### 概述

+ 验证(Verification)和确认(Validation)都是为了提升最终产品的质量而采取的措施。

+ 验证和确认的目的不同。

  + 验证是目的是确保选定的工作产品与事先指定给该工作产品的需求一致。这里的需求绝大多数情况下是指产品需求以及产品组件需求。
  + 确认的目标则是确保开发完成的产品或者产品组件在即将要使用该产品或者产品组件的环境中工作正确。因此，其关注的重点是客户需求的满足。
  + 因此，验证关注的是是否正确的把软件产品开发出来，即与需求规格一致；确认关注的是是否开发了正确的软件产品，即是否能帮用户解决实际问题。

+ 另一方面，验证和确认又是相互依存、关系紧密的两个活动。验证活动的依据来源于确认的目标，即产品组件需求必须与客户需求一致；验证活动为确认活动提供了前提条件，在完全产品需要和产品组件需求之前，考察客户需求是否满足是没有意义的。

### 流程

+ 环境准备

不管是验证工作还是确认工作，环境非常重要，对于验证工作来说，如果是同行评审，就需要准备文件材料、人员以及会议场所等；如果是测试，则可能需要模拟器、场景生成程序、环境控制以及其他系统接口等。对于确认工作而言，环境的准备更加重要，因为确认要考察的是在真实环境中产品是否工作正常，因此，要求尽可能模拟真实环境和场景。如果是模拟环境，则需要开展分析工作，以弄清模拟环境与真实环境的差别以及对测试结果的影响。

+ 对象选择

不是所有的工作产品都需要进行验证和确认。这一点在项目计划阶段都应当建立起相应的验证计划和确认计划。这里需要明确两个不同的概念，即产品和工作产品。产品是面向客户的，需要向客户提交的工作结果；而工作产品则往往是过程的直接结果。并不是所有的工作产品都需要向客户提交，因此，产品一定是工作产品，而反之则不成立。验证活动的对象往往从工作产品中选择而确认活动的对象则从产品中选择。

+ 活动实施

验证和确认的活动主要就是评审和测试。一般情况下，可以将整个项目生命周期中早期对产品需求评审工作和最后的验收测试作为确认工作，而其他的评审和测试工作当成是验证工作。当然，严格的划分验证活动还是确认活动还是应该从活动本身的目标出发，加以区分。

+ 结果分析

对于验证和确认工作的结果需要进行适当分析，以找出潜在问题和改进机会。如对于设计规格说明书的评审工作之外，应当分析一下设计过程的有效性，预测（Catch and Re-Catch）设计规格说明书中还隐藏的缺陷。对于验收测试结果的分析，往往可以重点考察那些一直遗留到验收阶段才被发现的缺陷，看看这些缺陷在什么阶段被引入，为什么前面未能发现等。